# 1.垃圾回收算法

![图片](../img/J9.png)

# 2.垃圾回收器

![图片](../img/J11.png)


## 2.1 Serial收集器(-XX:+UseSerialGC  -XX:+UseSerialOldGC)

    Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。
    它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集
    工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束。
![图片](../img/J10.png)


## 2.2 Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))

    Parallel收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，
    其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同，
    当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。

    Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。
    CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。
    所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 
    Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量

新生代采用复制算法，老年代采用标记-整理算法。


![图片](../img/J12.png)

    Parallel Old收集器是Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。
    在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器
    (JDK8默认的新生代和老年代收集器)。

## 2.3 ParNew收集器(-XX:+UseParNewGC)
    
    ParNew收集器其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。

新生代采用复制算法，老年代采用标记-整理算法。

![图片](../img/J13.png)
    

## 2.4 CMS收集器(-XX:+UseConcMarkSweepGC(old))

    CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
    它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，
    它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

    从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，
    它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。

![图片](../img/J14.png)

整个过程分为四个步骤：

    🚀 初始标记：暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快。
    🚀 并发标记：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，
        这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。
        因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。
    🚀 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动
        的那一部分对象的标记记录(主要是处理漏标问题)，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，
        远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法(见下面详解)做重新标记。
    🚀 并发清理：开启用户线程，同时GC线程开始对未标记的区域做清扫。
        这个阶段如果有新增对象会被标记为黑色不做任何处理(见下面三色标记算法详解)。
    🚀 并发重置：重置本次GC过程中的标记数据。


CMS的相关核心参数

    🚀 -XX:+UseConcMarkSweepGC：启用cms
    🚀 -XX:ConcGCThreads：并发的GC线程数
    🚀 -XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片）
    🚀 -XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次  
    🚀 -XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比）
    🚀 -XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整
    🚀 -XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，降低CMS GC标记阶段(也会对年轻代一起做标记，如果在minor gc就干掉了很多对垃圾对象，标记阶段就会减少一些标记时间)时的开销，一般CMS的GC耗时 80%都在标记阶段
    🚀 -XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW
    🚀 -XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;

## 2.5 G1


# 3.垃圾收集底层算法实现

## 三色标记法

在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，
多标和漏标的情况就有可能发生。漏标的问题主要引入了三色标记算法来解决。

    三色标记算法是把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：
    🚀 黑色： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 
        它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。
    🚀 灰色： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。
    🚀 白色： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 
        若在分析结束的阶段， 仍然是白色的对象， 即代表不可达

![图片](../img/J15.png)    




#### Java GCRoot

    🚀 虚拟机内部的引用，比如类加载器等；
    🚀 native，本地方法栈引用的对象(在本地方法栈)
    🚀 final，常量引用的对象（比如字符串常量池的引用；在方法区）
    🚀 static，静态变量引用的对象（比如Java类的引用类型静态变量；在方法区）
    🚀 synchronzied引用的对象(所有被同步锁持有的对象；在堆里)
    🚀 jvm虚拟机栈引用的对象(比如：各个线程被调用的方法堆栈中用到的参数、局部变量和临时变量；在jvm虚拟机栈中)
    🚀 Thread，活动的线程
    🚀 Class对象，由BootstrapClassLoader加载的对象是不能被回收的


## 漏标-读写屏障

    漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案：
增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB）

    增量更新就是当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 
    等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 
    这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。


    原始快照就是当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 
    在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，
    将白色对象直接标记为黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)

    以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。 

## 记忆集与卡表


在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了

    为此，在新生代可以引入记录集（Remember Set）的数据结构（记录从非收集区到收集区的指针集合），
    避免把整个老年代加入GCRoots扫描范围。事实上并不只是新生代、 老年代之间才有跨代引用的问题， 
    所有涉及部分区域收集（Partial GC） 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。
    
    垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。
    hotspot使用一种叫做“卡表”(Cardtable)的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系， 
    可以类比为Java语言中HashMap与Map的关系。
    卡表是使用一个字节数组实现：CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡页”。

    hotSpot使用的卡页是2^9大小，即512字节

![图片](../img/J16.png)   

一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0.
GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。

#### 卡表的维护

卡表变脏上面已经说了，但是需要知道如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1。
Hotspot使用写屏障维护卡表状态。



# 常见引用类型


java的引用类型一般分为四种：强引用、软引用、弱引用、虚引用

强引用：普通的变量引用

    public static User user = new User();

软引用：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，
则会把这些软引用的对象回收掉。软引用可用来实现内存敏感的高速缓存。

    public static SoftReference<User> user = new SoftReference<User>(new User());

    软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？
    这就要看具体的实现策略了。

    （1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建
    （2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出

弱引用：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，GC会直接回收掉，很少用

    public static WeakReference<User> user = new WeakReference<User>(new User());

虚引用：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用









