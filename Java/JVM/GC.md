# 1.垃圾回收算法

![图片](../img/J9.png)

# 2.垃圾回收器

![图片](../img/J11.png)


## 2.1 Serial收集器(-XX:+UseSerialGC  -XX:+UseSerialOldGC)

    Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。
    它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集
    工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束。
![图片](../img/J10.png)


## 2.2 Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))

    Parallel收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，
    其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同，
    当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。

    Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。
    CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。
    所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 
    Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量

新生代采用复制算法，老年代采用标记-整理算法。


![图片](../img/J12.png)

    Parallel Old收集器是Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。
    在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器
    (JDK8默认的新生代和老年代收集器)。

## 2.3 ParNew收集器(-XX:+UseParNewGC)
    
    ParNew收集器其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。

新生代采用复制算法，老年代采用标记-整理算法。

![图片](../img/J13.png)
    

## 2.4 CMS收集器(-XX:+UseConcMarkSweepGC(old))

    CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
    它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，
    它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

    从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，
    它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。

整个过程分为四个步骤：

    🚀 初始标记：暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快。
    🚀 并发标记：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，
        这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。
        因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。
    🚀 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动
        的那一部分对象的标记记录(主要是处理漏标问题)，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，
        远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法(见下面详解)做重新标记。
    🚀 并发清理：开启用户线程，同时GC线程开始对未标记的区域做清扫。
        这个阶段如果有新增对象会被标记为黑色不做任何处理(见下面三色标记算法详解)。
    🚀 并发重置：重置本次GC过程中的标记数据。


## 2.5 G1


# 3.垃圾收集底层算法实现

## 三色标记法