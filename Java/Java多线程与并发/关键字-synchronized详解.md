### 临界区（ Critical Section）

    一个程序运行多个线程本身是没有问题的，问题出在多个线程访问共享资源
    多个线程读共享资源其实也没有问题
    在多个线程对共享资源读写操作时发生指令交错，就会出现问题

    一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区，其共享资源为临界资源

```java

//临界资源
private static int counter = 0;

public static void increment() { //临界区
    counter++;
}

public static void decrement() {//临界区
    counter--;

```


### 竞态条件（ Race Condition ）
    多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件

为了避免临界区的竞态条件发生，有多种手段可以达到目的：

    🚀 阻塞式的解决方案：synchronized，Lock
    🚀 非阻塞式的解决方案：原子变量


## synchronized使用

    synchronized 同步块是 Java 提供的一种原子性内置锁，Java 中的每个对象都可以把它当作一个同步锁来使用，
    这些 Java 内置的使用者看不到的锁被称为内置锁，也叫作监视器锁。

![图片](img/J6.png)

synchronized 实际是用对象锁保证了临界区内代码的原子性

![图片](img/J7.png)


## synchronized底层原理

    synchronized是JVM内置锁，基于Monitor机制实现，依赖底层操作系统的互斥原语Mutex（互斥量），它是一个重量级锁，
    性能较低。当然，JVM内置锁在1.5之后版本做了重大的优化，如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、
    轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、自适应自旋（Adaptive Spinning）等技术来减少锁操作的开销，
    内置锁的并发性能已经基本与Lock持平。


#### Monitor（管程/监视器）

    Monitor，直译为“监视器”，而操作系统领域一般翻译为“管程”。管程是指管理共享变量以及对共享变量操作的过程，
    让它们支持并发。在Java 1.5之前，Java语言提供的唯一并发语言就是管程，Java 1.5之后提供的SDK并发包也是以管程为基础的。
    除了Java之外，C/C++、C#等高级语言也都是支持管程的。synchronized关键字和wait()、notify()、notifyAll()
    这三个方法是Java中实现管程技术的组成部分

MESA模型

    在管程的发展史上，先后出现过三种不同的管程模型，分别是Hasen模型、Hoare模型和MESA模型。
    现在正在广泛使用的是MESA模型。下面我们便介绍MESA模型：

![图片](img/J8.png)

wait()的正确使用姿势

    对于MESA管程来说，有一个编程范式：
```
while(条件不满足) {
    wait();
}
```
    唤醒的时间和获取到锁继续执行的时间是不一致的，被唤醒的线程再次执行时可能条件又不满足了，
    所以循环检验条件。MESA模型的wait()方法还有一个超时参数，为了避免线程进入等待队列永久阻塞。


notify()和notifyAll()分别何时使用

    满足以下三个条件时，可以使用notify()，其余情况尽量使用notifyAll()：
    🚀 所有等待线程拥有相同的等待条件；
    🚀 所有等待线程被唤醒后，执行相同的操作；
    🚀 只需要唤醒一个线程。


### Java语言的内置管程synchronized


![图片](img/J9.png)


## 对象的内存布局

Hotspot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

    🚀 对象头：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象才有）等。
    🚀 实例数据：存放类的属性数据信息，包括父类的属性信息；
    🚀 对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。

![图片](img/J10.png)

### 对象头详解

Mark Word

    用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，
    这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”

Klass Pointer

    对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
    32位4字节，64位开启指针压缩或最大堆内存<32g时4字节，否则8字节。
    jdk1.8默认开启指针压缩后为4字节，当在JVM参数中关闭指针压缩（-XX:-UseCompressedOops）后，长度为8字节。

数组长度（只有数组对象有）

    如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度。4字节

![图片](img/J11.png)








