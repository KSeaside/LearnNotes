### 事务及其ACID属性

    事务是由一组SQL语句组成的逻辑处理单元,事务具有以下4个属性,通常简称为事务的ACID属性。
    🚀 原子性(Atomicity) ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。
    🚀 一致性(Consistent) ：在事务开始和完成时,数据都必须保持一致状态。
        这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性。
    🚀 隔离性(Isolation) ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。
        这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。
    🚀 持久性(Durable) ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。


### 并发事务处理带来的问题

    🚀 更新丢失(Lost Update)或脏写
    当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。
    🚀 脏读（Dirty Reads）
    一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。
    一句话：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。
    🚀 不可重读（Non-Repeatable Reads）
    一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。
    一句话：事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性
    🚀 幻读（Phantom Reads）
    一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。
    一句话：事务A读取到了事务B提交的新增数据，不符合隔离性



### 事务隔离级别

    “脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数据库提供一定的事务隔离机制来解决。


![图片](img/M4.png)


    数据库的事务隔离越严格,并发副作用越小,但付出的代价也就越大,因为事务隔离实质上就是使事务在一定程度上“串行化”进行,这显然与“并发”是矛盾的。

    同时,不同的应用对读一致性和事务隔离程度的要求也是不同的,比如许多应用对“不可重复读"和“幻读”并不敏感,可能更关心数据并发访问的能力。
    常看当前数据库的事务隔离级别: show variables like 'tx_isolation';
    设置事务隔离级别：set tx_isolation='REPEATABLE-READ';
    Mysql默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用Mysql设置的隔离级别，如果Spring设置了就用已经设置的隔离级别

### 锁详解
锁是计算机协调多个进程或线程并发访问某一资源的机制。
在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。


### 锁分类

从性能上分为乐观锁(用版本对比来实现)和悲观锁

从对数据操作的粒度分，分为表锁和行锁

从对数据库操作的类型分，分为读锁和写锁(都属于悲观锁)，还有意向锁

读锁（共享锁，S锁(Shared)）：针对同一份数据，多个读操作可以同时进行而不会互相影响，比如：select * from T where id=1 lock in share mode
写锁（排它锁，X锁(eXclusive)）：当前写操作没有完成前，它会阻断其他写锁和读锁，数据修改操作都会加写锁，查询也可以通过for update加写锁，
比如：select * from T where id=1 for update

意向锁（Intention Lock）：又称I锁，针对表锁，主要是为了提高加表锁的效率，是mysql数据库自己加的。

当有事务给表的数据行加了共享锁或排他锁，同时会给表设置一个标识，代表已经有行锁了，其他事务要想对表加表锁时，
就不必逐行判断有没有行锁可能跟表锁冲突了，直接读这个标识就可以确定自己该不该加表锁。特别是表中的记录很多时，
逐行判断加表锁的方式效率很低。而这个标识就是意向锁。
意向锁主要分为：

    意向共享锁，IS锁，对整个表加共享锁之前，需要先获取到意向共享锁。
    意向排他锁，IX锁，对整个表加排他锁之前，需要先获取到意向排他锁。


### 临键锁(Next-key Locks)

Next-Key Locks是行锁与间隙锁的组合

无索引行锁会升级为表锁(RR级别会升级为表锁，RC级别不会升级为表锁)

锁主要是加在索引上，如果对非索引字段更新，行锁可能会变表锁
session1 执行：update account set balance = 800 where name = 'lilei';
session2 对该表任一行操作都会阻塞住
InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。

锁定某一行还可以用lock in share mode(共享锁) 和for update(排它锁)，例如：select * from test_innodb_lock where a = 2 for update; 
这样其他session只能读这行数据，修改则会被阻塞，直到锁定行的session提交

### 锁优化建议

    尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
    合理设计索引，尽量缩小锁的范围
    尽可能减少检索条件范围，避免间隙锁
    尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行
    尽可能低级别事务隔离









